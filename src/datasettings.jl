name(ds :: DataSettings) = ds.name;

"""
$(SIGNATURES)

Number of school groups (e.g. HSG, SC, CG). For wage regressions.
"""
n_school(ds :: DataSettings) = ds.nSchool;

"""
	$(SIGNATURES)

Number of college quality groups.
"""
n_colleges(ds :: DataSettings) = ds.nColleges;

"""
	$(SIGNATURES)

Number of two year colleges.
"""
n_2year(ds :: DataSettings) = ds.n2Year;

"""
	$(SIGNATURES)

Number of HS GPA or AFQT groups.
"""
n_gpa(ds :: DataSettings) = length(hsgpa_ub(ds));

"""
	$(SIGNATURES)

Number of parental background groups.
"""
n_parental(ds :: DataSettings) = length(parental_ub(ds));

"""
	$(SIGNATURES)

Percentile upper bounds for GPA groups.
"""
hsgpa_ub(ds :: DataSettings) = ds.hsGpaUbV;

"""
	$(SIGNATURES)

Percentile upper bounds for parental groups.
"""
parental_ub(ds :: DataSettings) = ds.parentalUbV;

hsgpa_edges(ds :: DataSettings) = vcat(0.0, hsgpa_ub(ds));
hsgpa_masses(ds :: DataSettings) = diff(hsgpa_edges(ds));
parental_edges(ds :: DataSettings) = vcat(0.0, parental_ub(ds));
parental_masses(ds :: DataSettings) = diff(parental_edges(ds));
mass_gpa_yp(ds :: DataSettings) = hsgpa_masses(ds) * parental_masses(ds)';

# Mean of a Vector by HS GPA
mean_by_gpa(x_pV :: Vector{T1}, ds :: DataSettings) where T1 <: Number = 
	sum(x_pV .* hsgpa_masses(ds));
mean_by_parental(x_pV :: Vector{T1}, ds :: DataSettings) where T1 <: Number = 
	sum(x_pV .* parental_masses(ds));

function mean_by_qual(x_qV :: AbstractVector{T1}, 
	ds :: DataSettings) where T1 <: Number
	
	enroll_qV, _ = frac_enroll_by_qual(ds);
	return sum(x_qV .* enroll_qV);
end

mean_by_gpa_yp(x_gpM :: Matrix{T1}, ds :: DataSettings) where T1 <: Number =
    sum(x_gpM .* mass_gpa_yp(ds));


"""
	$(SIGNATURES)

Given college indices, which ones are two year colleges?
"""
is_two_year(ds :: DataSettings, cIdx :: Integer) = (cIdx .<= n_2year(ds))


"""
	$(SIGNATURES)

Set of two year college indices.
Returns a range, so that assignments of the form 
	`m[two_year_colleges(ds)] .= 0.0`
work.
"""
two_year_colleges(ds :: DataSettings) = (1 : n_2year(ds));

"""
	$(SIGNATURES)

Set of four year college indices.
"""
four_year_colleges(ds :: DataSettings) = (n_2year(ds) + 1) : n_colleges(ds);

"""
	$(SIGNATURES)

Can one graduate from this college?
"""
can_graduate(ds :: DataSettings, cIdx :: Integer) = !is_two_year(ds, cIdx);

"""
	$(SIGNATURES)

List of colleges from which one cannot graduate.
"""
no_grad_idx(ds :: DataSettings) = two_year_colleges(ds);

"""
	$(SIGNATURES)

List of colleges from which students can graduate.
"""
grad_idx(ds :: DataSettings) =
	findall(cIdx -> can_graduate(ds, cIdx),  1 : n_colleges(ds))

credits_to_courses(ds :: DataSettings, nCredits) = 
	nCredits ./ ds.creditsPerCourse;
courses_to_credits(ds :: DataSettings, nCourses) = 
	nCourses .* ds.creditsPerCourse;


## --------------  Individual settings

"""
	$(SIGNATURES)

Make named data settings. Each defines at least:

- `rawBaseDir`: location where raw data files are copied from.
- `dataSubDir`: sub directory where copied data files are stored.
"""
function make_data_settings(dsName :: Symbol)
	if dsName == :default
		rawDir = joinpath(raw_base_dir(), "Updated Types", 
			"NLSY 97 moments by AFQT");
		return DataSettings(name = :default, rawBaseDir = rawDir)
	elseif dsName == :test
		rawDir = joinpath(raw_base_dir(), "Updated Types", 
			"NLSY 97 moments by AFQT");
		return DataSettings(name = :test, rawBaseDir = rawDir)
	else
		error("Invalid name: $dsName")
	end
end

test_data_settings() = make_data_settings(:test);


# Raw data files live here; generated by Oksana
raw_data_base_dir(ds :: DataSettings) = ds.rawBaseDir;
data_sub_dir(ds :: DataSettings) = ds.dataSubDir;

# function raw_data_base_dir(ds :: DataSettings)
#     if name(ds) == :default  ||  name(ds) == :test
#         d = "/Users/lutz/Dropbox/Dropout Policies/Data/empiricaltargets/NLSY 97 moments by AFQT";
#     else
#         error("Invalid: $ds");
#     end
#     return d
# end


## ----------  Show

function Base.show(io :: IO, ds :: DataSettings)
	print(io,  "DataSettings ", name(ds), " with ", n_colleges(ds), " colleges.")
end

function settings_table(ds :: DataSettings)
    # borrowLimitV = borrow_limits(ds, modelUnits = false);
	# borrowLimitV = round.(borrowLimitV, digits = 0);
	gpaUbV = round.(hsgpa_ub(ds), digits = 2);
	pUbV = round.(parental_ub(ds), digits = 2);
    return [
		"DataSettings"  " ";
		"GPA classes"  "$gpaUbV";
		"Parental classes"  "$pUbV"
        # "Borrowing limits"  "$borrowLimitV"
    ]
end


# --------------